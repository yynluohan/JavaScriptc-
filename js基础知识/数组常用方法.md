# 数组常用方法 #

## 目录 ##

 1. [创建数组的三种方式](#href1)
    1. [new Array()](#href1-1)
    2. [new Array()](#href1-2)
    3. [根据字面量形式](#href1-3)
 2. [判断一个对象是否为数组的方法](#href2)
    1. [instanceof](#href2-1)
    2. [Array.isArray()](#href2-2)
    3. [Object.prototype.toString.call()](#href2-3)
    4. [constructor.name](#href2-4)
 3. [数组常用方法](#href3)
    1. [push()](#href3-1)
    2. [pop()](#href3-2)
    3. [shift()](#href3-3)
    4. [unshift](#href3-4)
    5. [splice()](#href3-5)
    6. [concat()](#href3-6)
    7. [sort()](#href3-7)
    8. [map()](#href3-8)

## <a name='#href1'>创建数组的三种方式</a> ##

### <a name='#href1-1'>new Array()</a> ###

```js
var list = new Array();
list[0] = 1;
list[1] = 2;
console.log(list); // [1,2]
```


### <a name='#href1-2'>new Array()</a> ###

```js
var list = new Array(1,2,'a');
console.log(list);  // [1,2,'a']
```


### <a name='#href1-3'>根据字面量形式</a> ###

```js
var list = [1,2,3];
```


## <a name='#href2'>判断一个对象是否为数组的方法</a> ##

### <a name='#href2-1'>instanceof</a> ###

instanceof 是一个二元操作符，左边是操作对象，右边操作数是一个函数对象或者函数构造器。
原则上是通过判断左边操作数的对象的原型链上是否具有右边操作数的构造函数的prototype属性。
如果有的话，则返回true,否则返回false。

```js
var list = [1,2,3];
var str = '123';
var obj = {
  name: '张三'
}

console.log(str instanceof Array);  // false
console.log(obj instanceof Array);  // false
console.log(list instanceof Array);  // true

```

### <a name='#href2-2'>Array.isArray()</a> ###

Array.isArray(arr)  //arr为检测的变量，如果为数组的话，则返回true,否则返回false。

```js
var list = [1,2,3];
var obj = {
  name: '张三'
}

console.log(Array.isArray(list)); // true
console.log(Array.isArray(obj));  // false
```

### <a name='#href2-3'>Object.prototype.toString.call()</a> ###

Object.prototype,toString.call(arr) 检测如果是数组的话，则返回"[object Array]"

```js
var list = [1,2,3];
var obj = {
  name: '张三'
}

console.log(Object.prototype.toString.call(list) === '[object Array]'); // true
console.log(Object.prototype.toString.call(obj) === '[object Array]');  // false
console.log(Object.prototype.toString.call(obj) === '[object Object]'); // true
```

### <a name='#href2-4'>constructor.name</a> ###

可以根据constructor对象中的name属性来判断，如果是数组的话，name的属性为 'Array'。

```js
var list = [1,2,3];
var obj = {
  name: '张三'
}

console.log(list.contractor.name === 'Array');  // true
console.log(obj.contractor.name === 'Array');   // false
console.log(obj.contractor.name === 'Object'); //true
```


## <a name='#href3'>数组常用方法</a> ##


### <a name='#href3-1'>push()</a> ###

arr.push() //从后面添加元素，返回值为添加完后的数组的长度。

```js
var list = [1,2,3];

console.log(list.push(4,'5'));  //返回数组的长度  5
console.log(list);  // [1,2,3,4,'5']
```

### <a name='#href3-2'>pop()</a> ###

arr.pop()  //从后面删除元素，每次调用只删除一个元素，返回删除的元素

```js
var list = [1,2,3];

console.log(list.pop());  //返回被删除的元素  3
console.log(list);  // [1,2]
```


### <a name='#href3-3'>shift()</a> ###

arr.shift()  //从前面删除元素，每次调用只能删除一个，返回是删除的元素。

```js
var list = [1,2,3];

console.log(list.shift()); // 1
console.log(list);  // [2,3]
```

### <a name='#href3-4'>unshift()</a> ###

arr.unshift()  //从前面添加元素，可添加多个，返回值是数组的长度

```js
var list = [1,2,3];

console.log(list.unshift('-1',0));  // 5
console.log(list);  // ['-1',0,1,2,3]
```

### <a name='#href3-5'>splice()</a> ###

arr.splice(i,n) //i表示索引值(从哪个位置开始删除)，n表示删除的个数，返回值是被删除的数组。

```js
var list = [1,2,3,4,5,6];

console.log(list.splice(0,2));  // [1,2]
console.log(list);  // [3,4,5,6]

```

### <a name='#href3-6'>concat()</a> ###

arr.concat()  //拼接数组(可以是多个)，返回值是拼接之后的数组。

```js
var list = [1,2,3];

console.log(list.concat([4,5,6])); // [1,2,3,4,5,6]
console.log(list);  // [1,2,3]
```

### <a name='#href3-7'>sort()</a> ###






### <a name='#href3-8'>map()</a> ###


```js
var list = [1,2,3];
list.map(item => item*2);
console.log(list);  // [2,4,6]
```
