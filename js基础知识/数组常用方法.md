# 数组常用方法 #

## 目录 ##

 1. [创建数组的三种方式](#href1)
    1. [new Array()](#href1-1)
    2. [new Array()](#href1-2)
    3. [根据字面量形式](#href1-3)
 2. [判断一个对象是否为数组的方法](#href2)
    1. [instanceof](#href2-1)
    2. [Array.isArray()](#href2-2)
    3. [Object.prototype.toString.call()](#href2-3)
    4. [constructor.name](#href2-4)
 3. [数组常用方法](#href3)
    1. [push()](#href3-1)
    2. [pop()](#href3-2)
    3. [shift()](#href3-3)
    4. [unshift](#href3-4)
    5. [splice()](#href3-5)
    6. [concat()](#href3-6)
    7. [sort()](#href3-7)
    8. [reverse()](#href3-8)
    9. [slice()](#href3-9)
    10. [forEach()](#href3-10)
    11. [map()](#href3-11)
    12. [filter()](#href3-12)
    13. [every()](#href3-13)

## <a name='href1'>创建数组的三种方式</a> ##

### <a name='href1-1'>new Array()</a> ###

```js
var list = new Array();
list[0] = 1;
list[1] = 2;
console.log(list); // [1, 2]
```


### <a name='href1-2'>new Array()</a> ###

```js
var list = new Array(1,2,'a');
console.log(list);  // [1, 2, 'a']
```


### <a name='href1-3'>根据字面量形式</a> ###

```js
var list = [1, 2, 3];
```


## <a name='href2'>判断一个对象是否为数组的方法</a> ##

### <a name='href2-1'>instanceof</a> ###

instanceof 是一个二元操作符，左边是操作对象，右边操作数是一个函数对象或者函数构造器。
原则上是通过判断左边操作数的对象的原型链上是否具有右边操作数的构造函数的prototype属性。
如果有的话，则返回true,否则返回false。

```js
var list = [1, 2, 3];
var str = '123';
var obj = {
  name: '张三'
}

console.log(str instanceof Array);  // false
console.log(obj instanceof Array);  // false
console.log(list instanceof Array);  // true

```

### <a name='href2-2'>Array.isArray()</a> ###

Array.isArray(arr)  //arr为检测的变量，如果为数组的话，则返回true,否则返回false。

```js
var list = [1, 2, 3];
var obj = {
  name: '张三'
}

console.log(Array.isArray(list)); // true
console.log(Array.isArray(obj));  // false
```

### <a name='href2-3'>Object.prototype.toString.call()</a> ###

Object.prototype,toString.call(arr) 检测如果是数组的话，则返回"[object Array]"

```js
var list = [1, 2, 3];
var obj = {
  name: '张三'
}

console.log(Object.prototype.toString.call(list) === '[object Array]'); // true
console.log(Object.prototype.toString.call(obj) === '[object Array]');  // false
console.log(Object.prototype.toString.call(obj) === '[object Object]'); // true
```

### <a name='href2-4'>constructor.name</a> ###

可以根据constructor对象中的name属性来判断，如果是数组的话，name的属性为 'Array'。

```js
var list = [1, 2, 3];
var obj = {
  name: '张三'
}

console.log(list.contractor.name === 'Array');  // true
console.log(obj.contractor.name === 'Array');   // false
console.log(obj.contractor.name === 'Object'); //true
```


## <a name='href3'>数组常用方法</a> ##


### <a name='href3-1'>push()</a> ###

arr.push() //从后面添加元素，返回值为添加完后的数组的长度。

```js
var list = [1, 2, 3];

console.log(list.push(4,'5'));  //返回数组的长度  5
console.log(list);  // [1, 2, 3, 4, '5']
```

### <a name='href3-2'>pop()</a> ###

arr.pop()  //从后面删除元素，每次调用只删除一个元素，返回删除的元素

```js
var list = [1, 2, 3];

console.log(list.pop());  //返回被删除的元素  3
console.log(list);  // [1, 2]
```


### <a name='href3-3'>shift()</a> ###

arr.shift()  //从前面删除元素，每次调用只能删除一个，返回是删除的元素。

```js
var list = [1, 2, 3];

console.log(list.shift()); // 1
console.log(list);  // [2, 3]
```

### <a name='href3-4'>unshift()</a> ###

arr.unshift()  //从前面添加元素，可添加多个，返回值是数组的长度

```js
var list = [1, 2, 3];

console.log(list.unshift('-1',0));  // 5
console.log(list);  // ['-1', 0, 1, 2, 3]
```

### <a name='href3-5'>splice()</a> ###

arr.splice(i,n) //i表示索引值(从哪个位置开始删除)，n表示删除的个数，返回值是被删除的数组。

```js
var list = [1, 2, 3, 4, 5, 6];

console.log(list.splice(0,2));  // [1, 2]
console.log(list);  // [3, 4, 5, 6]

```

### <a name='href3-6'>concat()</a> ###

arr.concat()  //拼接数组(可以是多个)，返回值是拼接之后的数组。

```js
var list = [1, 2, 3];

console.log(list.concat([4,5,6])); // [1, 2, 3, 4, 5, 6]
console.log(list);  // [1, 2, 3]
```

### <a name='href3-7'>sort()</a> ###

arr.sort(fuc)  // 接收一个方法，方法内可对排序进行处理。若不传方法，则默认是根据Unicode来排序。

```js
var list = [1, 12, 3, 15, 6, 21];

console.log(list.sort());  // [1, 12, 15, 21, 3, 6]
console.log(list.sort((a,b) => a-b));  // [1, 3, 6, 12, 15, 21]
console.log(list.sort((a,b) => b-a));  // [21, 15, 12, 6, 3, 1]
```


### <a name='href3-8'>reverse()</a> ###

arr.reverse()   // 将数组反转，返回的是反转后的数组。

```js
var list = [1,2,3,4];

console.log(list.reverse()); // [4, 3, 2, 1]
```


### <a name='href3-9'>slice()</a> ###

arr.slice(start,end)  //截取索引值start到end(不包含)的数组，返回的是截取之后的数组。

```js
var list = [1, 2, 3, 4, 5];

console.log(list.slice(1));  // [2, 3, 4, 5]
console.log(list.slice(1,3))  // [2, 3]
```


### <a name='href3-10'>forEach()</a> ###

arr.forEach(callBack)  // 遍历数组，无return

```
callBack的参数： value: 当前索引的值
                index: 当前索引
                array：原数组
```

```js
var list = [1, 2, 3, 4];
list.forEach((value,index,array) => {
  console.log(value,index,array);  // 第一次： 1 0 [1, 2, 3, 4]
})
```


### <a name='href3-11'>map()</a> ###

arr.map(callback)  //遍历数组，callBack参数与forEach一致。有return 返回一个新数组

```js
var list = [1, 2, 3];
list.map(item => item*2);
console.log(list);  // [2, 4, 6]
```

注意：forEach()与map()的区别
(1) arr.forEach() 没有return;  而arr.map() 有return



### <a name='href3-12'>filter()</a> ###

arr.filter(callBack)  //过滤数组，返回满足条件的数组。

```js
var list = [1, 2, 3, 4];

console.log(list.filter(x => x > 2)); // [3, 4]
```


### <a name='href3-13'>every()<a> ###

arr.every(callBack)  // 根据依据条件，如果数组的元素全部满足条件，则返回true,否则返回false。

```js
var list = [1, 2, 3, 4];

console.log(list.every(x => x > 2));  // false
console.log(list.every(x => x > 0));  // true
```
