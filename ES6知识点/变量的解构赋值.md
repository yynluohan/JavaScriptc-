# ES6变量的解构赋值 #

## 目录 ##

1 [基本用法](#href1)

## 基本用法 ##
ES6允许按照一定模式，从数组或者对象中提取值，对变量进行赋值，称之为**解构**。

```js
以前，为变量赋值，只能直接指定值。

var a = 1;
var b = 2;
var c = 3;
```

```js
ES6允许写成这样：

var [a, b, c] = [1, 2, 3]; //按照对应关系，对变量进行赋值。

//a = 1; b = 2; c = 3;
```
本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。

```js
let [foo, [[bar], baz]] = [1, [2], 3];

//foo = 1; bar = 2; baz = 3;
```

```js
let [, , three] = ["foo", "bar", "baz"];

// three = "baz"
```

```js
let [x, , z] = [1, 2, 3];

// x = 1; z = 3
```

```js
let [head, ...tail] = [1, 2, 3, 4];

// head = 1; tail = [2, 3, 4];  注意：这里的tail是数值。

如果解构不成功，变量的值就等于undefined

let [x, y, ...z] = ["a"];

// x = "a"; y = undefined; z = []
```

** 不完全解构 **
即等号左边的模式，只匹配一部分的等号右边的数组，这种情况下，解构依旧成功。

```js
let [x, y] = [1, 2, 3];

//x = 1; y = 3;

let [a, [b], c] = [1, [2, 3], 4];

// a = 1; b = 2; c = 4;
```

** 如果等号的右边不是数组（严格来说，不是可遍历的结构），那么会报错 **

```js
//报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
```

```js
对于Set结构，也可以使用数组的解构赋值。
Set为ES6新增的，本身是一个构造函数，用来生成Set数据结构。

let [x, y, z] = new Set(['a', 'b', 'c']);
// x = 'a'; y = 'b'; z = 'c'


题外话：可以使用new Set()实现数组去重的方法
var x4 = [1, 2, 3, 2, 4, 2, 5];
console.log([...new Set(x4)])  //[1, 2, 3, 4, 5]
```
